!function(e){function t(t){for(var r,s,i=t[0],l=t[1],c=t[2],u=0,m=[];u<i.length;u++)s=i[u],Object.prototype.hasOwnProperty.call(o,s)&&o[s]&&m.push(o[s][0]),o[s]=0;for(r in l)Object.prototype.hasOwnProperty.call(l,r)&&(e[r]=l[r]);for(p&&p(t);m.length;)m.shift()();return a.push.apply(a,c||[]),n()}function n(){for(var e,t=0;t<a.length;t++){for(var n=a[t],r=!0,i=1;i<n.length;i++){var l=n[i];0!==o[l]&&(r=!1)}r&&(a.splice(t--,1),e=s(s.s=n[0]))}return e}var r={},o={0:0},a=[];function s(t){if(r[t])return r[t].exports;var n=r[t]={i:t,l:!1,exports:{}};return e[t].call(n.exports,n,n.exports,s),n.l=!0,n.exports}s.m=e,s.c=r,s.d=function(e,t,n){s.o(e,t)||Object.defineProperty(e,t,{enumerable:!0,get:n})},s.r=function(e){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},s.t=function(e,t){if(1&t&&(e=s(e)),8&t)return e;if(4&t&&"object"==typeof e&&e&&e.__esModule)return e;var n=Object.create(null);if(s.r(n),Object.defineProperty(n,"default",{enumerable:!0,value:e}),2&t&&"string"!=typeof e)for(var r in e)s.d(n,r,function(t){return e[t]}.bind(null,r));return n},s.n=function(e){var t=e&&e.__esModule?function(){return e.default}:function(){return e};return s.d(t,"a",t),t},s.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},s.p="/dist/bundle/";var i=window.webpackJsonp=window.webpackJsonp||[],l=i.push.bind(i);i.push=t,i=i.slice();for(var c=0;c<i.length;c++)t(i[c]);var p=l;a.push([45,1]),n()}({0:function(e,t){e.exports=React},1:function(e,t){e.exports=MaterialUI},20:function(e,t){e.exports=ReactDOM},273:function(e,t,n){"use strict";n.r(t);var r=n(0),o=n(44),a=n(3),s=n(1),i=n(25);function l(){return(l=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var n=arguments[t];for(var r in n)Object.prototype.hasOwnProperty.call(n,r)&&(e[r]=n[r])}return e}).apply(this,arguments)}function c(e,t){if(null==e)return{};var n,r,o=function(e,t){if(null==e)return{};var n,r,o={},a=Object.keys(e);for(r=0;r<a.length;r++)n=a[r],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(r=0;r<a.length;r++)n=a[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var p=r.forwardRef((function(e,t){var n=e.to,o=c(e,["to"]);return r.createElement(i.b,l({innerRef:t,to:n},o))})),u=Object(s.makeStyles)((function(e){return{appbar:{backgroundColor:"#3C75E6"},toolbar:{minHeight:64},grow:{flexGrow:1},title:{color:e.palette.common.white,textDecoration:"none",fontWeight:500,fontSize:36,"&:hover":{textDecoration:"none"}},logo:{display:"inline-block",verticalAlign:"middle",height:40,width:62,marginRight:e.spacing(1)}}}),{name:"Header"}),m=function(){var e=u();return r.createElement(s.AppBar,{className:e.appbar,position:"fixed"},r.createElement(s.Toolbar,{className:e.toolbar},r.createElement(s.Link,{className:e.title,component:p,to:"/"},r.createElement(s.Hidden,{smDown:!0},"TrejGun`s blog")),r.createElement("div",{className:e.grow})))},h=Object(s.makeStyles)((function(e){return{root:{overflowY:"auto",overflowX:"hidden",display:"flex",minHeight:"100vh",position:"relative"},container:e.mixins.gutters({paddingTop:e.spacing(10),"& p":{"& *":{paddingLeft:5,paddingRight:5}}})}}),{name:"Layout"}),d=function(e){var t=e.children,n=h();return r.createElement("div",{className:n.root},r.createElement(m,null),r.createElement(s.Container,{className:n.container,maxWidth:"md"},t))},f=function(){return r.createElement("div",null,r.createElement(s.Typography,{component:"h2",variant:"h4"},"Hello! I`m TrejGun and this is my blog :)"),r.createElement("ul",null,r.createElement("li",null,r.createElement(s.Link,{component:p,to:"/articles/bindings-for-using-final-form-with-material-ui-autocomplete"},"Bindings for using Final Form with Material UI Autocomplete")),r.createElement("li",null,r.createElement(s.Link,{component:p,to:"/articles/ssr-nextjs-authentication-for-graphql-nestjs-application"},"SSR Next.js authentication for GraphQL Nest.js application")),r.createElement("li",null,r.createElement(s.Link,{component:p,to:"/articles/apollo-client-for-authorization-with-nestjs"},"Apollo client for authorization with Nest.js")),r.createElement("li",null,r.createElement(s.Link,{component:p,to:"/articles/how-to-convert-http-exception-to-rpc-exception"},"How to convert HttpException to RpcException?")),r.createElement("li",null,r.createElement(s.Link,{component:p,to:"/articles/collecting-data-from-workers-in-nestjs"},"Collecting data from workers in Nest.js")),r.createElement("li",null,r.createElement(s.Link,{component:p,to:"/articles/nova-poshta-google-maps-widget"},"Nova Poshta Google Maps widget")),r.createElement("li",null,r.createElement(s.Link,{component:p,to:"/articles/graphql-based-authorization-for-nestjs"},"GraphQL based authorization for Nest.js")),r.createElement("li",null,r.createElement(s.Link,{component:p,to:"/articles/jwt-based-authorization-for-nestjs"},"JWT based authorization for Nest.js")),r.createElement("li",null,r.createElement(s.Link,{component:p,to:"/articles/ethereum-server-for-nestjs"},"Ethereum Server for Nest.js")),r.createElement("li",null,r.createElement(s.Link,{component:p,to:"/articles/session-based-authorization-for-nestjs"},"Session based authorization for Nest.js")),r.createElement("li",null,r.createElement(s.Link,{component:p,to:"/articles/custom-transport-for-nestjs"},"Custom Transport for Nest.js")),r.createElement("li",null,r.createElement(s.Link,{component:p,to:"/terms-and-conditions"},"Terms and Conditions")),r.createElement("li",null,r.createElement(s.Link,{component:p,to:"/about"},"About this site"))))};function g(){return(g=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var n=arguments[t];for(var r in n)Object.prototype.hasOwnProperty.call(n,r)&&(e[r]=n[r])}return e}).apply(this,arguments)}var b=r.forwardRef((function(e,t){var n=g({},e);return r.createElement(s.Link,g({innerRef:t,rel:"noopener noreferrer nofollow",target:"_blank"},n))})),y=Object(s.makeStyles)((function(){return{date:{float:"right",color:"#c0c0c0"}}}),{name:"MyDate"}),E=function(e){var t=e.date,n=y();return r.createElement("div",{className:n.date},new Date(t).toISOString().split("T")[0])},v=n(279),w=n(277);function k(){return(k=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var n=arguments[t];for(var r in n)Object.prototype.hasOwnProperty.call(n,r)&&(e[r]=n[r])}return e}).apply(this,arguments)}function T(e,t){if(null==e)return{};var n,r,o=function(e,t){if(null==e)return{};var n,r,o={},a=Object.keys(e);for(r=0;r<a.length;r++)n=a[r],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(r=0;r<a.length;r++)n=a[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var j=function(e){var t=e.children,n=T(e,["children"]);return r.createElement(v.a,k({style:w.a},n),t)},x=n(34),R=function(e){var t=e.slug;return"ReactSnap"===navigator.userAgent?null:r.createElement(x.FacebookProvider,{appId:"471903663420767"},r.createElement(x.Comments,{href:"https://trejgun.github.io/articles/".concat(t)}))},S=function(){return r.createElement("div",null,r.createElement(E,{date:"2019-10-25T17:42:20.324Z"}),r.createElement(s.Typography,{component:"h2",variant:"h4"},"Custom Transport for Nest.js"),r.createElement("p",null,"Yesterday I tried to implement ",r.createElement("em",null,"CustomTransportStrategy")," for Nest.js and after googling for half an hour I realize there are only examples for RabbitMQ like this",r.createElement(b,{href:"https://github.com/AlariCode/nestjs-rmq"},"nestjs-rmq"),", which is already included in ",r.createElement("em",null,"@nestjs/microservice")," package. But there were nothing simple where one can see a logic related only to Nest.js itself until now"),r.createElement("p",null,"For this example I will implement simple ",r.createElement("em",null,"EventEmitter")," using setInterval, which emits timestamp each second, but in real life it could be anything like TCP calls, queue in any kind of SQL/NOSQL database, ZeroMQ, AWS SQS or Google pub/sub"),r.createElement(j,{language:"typescript"},'import {EventEmitter} from "events";\n\n\nexport class Ticker extends EventEmitter {\n  private intervalId: NodeJS.Timeout | null = null;\n\n  start(): void {\n    this.intervalId = setInterval(() => {\n      this.emit("data", Date.now());\n    }, 1000);\n  }\n\n  stop(): void {\n    if (this.intervalId) {\n      clearInterval(this.intervalId);\n    }\n  }\n}\n'),r.createElement("p",null,"Now a listener should be attached to listen to this ",r.createElement("em",null,"Ticker")," events (timestamp) and pass them to corresponding handler. For this I have to implement only two methods ",r.createElement("em",null,"listen")," and ",r.createElement("em",null,"close"),"."),r.createElement(j,{language:"typescript"},'import {Server, CustomTransportStrategy, MessageHandler} from "@nestjs/microservices";\nimport {Ticker} from "./ticker";\n\n\nexport class TickerServer extends Server implements CustomTransportStrategy {\n  private ticker: Ticker;\n\n  public listen(callback: () => void): void {\n    this.ticker = new Ticker();\n    this.ticker.start();\n    this.ticker.on("data", (e: number) => {\n      this.listener(e);\n    });\n    callback();\n  }\n\n  public async listener(e: number): Promise<void> {\n    const handler: MessageHandler | undefined = this.messageHandlers.get("TICK");\n    if (!handler) {\n      return;\n    }\n    const result = await handler(e);\n    console.log(result);\n  }\n\n  public close(): void {\n    this.ticker.stop();\n  }\n}\n'),r.createElement("p",null,"But the docs are silent about how to path event to controller. Event listeners of all controllers are stored in",r.createElement("em",null,"messageHandlers")," property. It also looks like it makes no sense to path object as event pattern because it is just stringified."),r.createElement("p",null,"Finally here is a controller to handle ",r.createElement("em",null,"TICK")," message, it is dead simple. The value returned from controller can be used to remove message from queue."),r.createElement(j,{language:"typescript"},'import {Controller} from "@nestjs/common";\nimport {MessagePattern} from "@nestjs/microservices";\n\n@Controller()\nexport class TickerController {\n  @MessagePattern("TICK")\n  public ticker(data: number): Promise<number> {\n    return Promise.resolve(data);\n  }\n}\n'),r.createElement("p",null,"This is all for today, good luck with your code!"),r.createElement(R,{slug:"custom-transport-for-nestjs"}))},A=function(){return r.createElement("div",null,r.createElement(E,{date:"2019-10-26T14:08:19.626Z"}),r.createElement(s.Typography,{component:"h2",variant:"h4"},"Session based authorization for Nest.js"),r.createElement("p",null,"I wrote this code some time ago and then made an example repo out of it because was going to write an article and publish it somewhere on medium or habr, but changed my plans and started this blog, where I don`t need to have positive karma or any other kind of rating to publish articles."),r.createElement(s.Typography,{component:"h3",variant:"h5"},"Problem"),r.createElement("p",null,"Me and as appeared a lot of other users want to have an application which includes such features"),r.createElement("ul",null,r.createElement("li",null,"Authorization with login/password"),r.createElement("li",null,"Authorization with social networks"),r.createElement("li",null,"Private/Public areas (controllers/routes)"),r.createElement("li",null,"Role based ACL"),r.createElement("li",null,"Persisted sessions")),r.createElement("p",null,"But unfortunately there were no good docs covering this part of framework. I mean there are, couple of pages in official documentation ",r.createElement(b,{href:"https://docs.nestjs.com/guards"},"Guards"),",",r.createElement(b,{href:"https://docs.nestjs.com/techniques/authentication"},"Authentication"),";",r.createElement(b,{href:"https://dev.to/nestjs/authentication-and-sessions-for-mvc-apps-with-nestjs-55a4"},"one good article with code samples"),"from @johnbiundo about local authorization; several closed issues and a few outdated blog posts. All these links did not give me a whole picture of how authorizations should be build."),r.createElement(s.Typography,{component:"h3",variant:"h5"},"Solution"),r.createElement("p",null,"This example is a fully functional",r.createElement(b,{href:"https://github.com/TrejGun/session-based-authorization-for-nestjs"},"boilerplate"),"with all features mentioned above. It also includes some very basic tests, typeorm, migrations and utils. I tried to make it simple, so you can adjust it for your own needs"),r.createElement(R,{slug:"session-based-authorization-for-nestjs"}))},I=function(){return r.createElement("div",null,r.createElement(E,{date:"2019-10-27T10:11:34.152Z"}),r.createElement(s.Typography,{component:"h2",variant:"h4"},"Ethereum Server for Nest.js"),r.createElement("p",null,"This is the second article about custom transports for Nest.js, you can find first one",r.createElement(s.Link,{component:p,to:"/articles/custom-transport-for-nestjs"},"here")),r.createElement("p",null,"Nets.js microservice can subscribe to events from any source, why not use a blockchain. In this example I will use Ethereum, but all other blockchains integration can be done easily using this pattern."),r.createElement("p",null,"Basic building block of any blockchain is a Block (deduction, man!) that is what server will listen to"),r.createElement(j,{language:"typescript"},'import {EMPTY, Observable} from "rxjs";\nimport {CustomTransportStrategy, MessageHandler, Server} from "@nestjs/microservices";\nimport Web3 from "web3";\nimport {Block, BlockHeader} from "web3/eth/types";\n\n\nexport class EthereumServer extends Server implements CustomTransportStrategy {\n  private subscription: any;\n\n  public listen(callback: () => void): void {\n    this.listenToBlocks();\n    callback();\n  }\n\n  private listenToBlocks(): void {\n    const web3: Web3 = new Web3(new Web3.providers.WebsocketProvider(process.env.SOCKET_ADDRESS));\n    this.subscription = web3.eth.subscribe("newBlockHeaders", (error: Error, blockHeader: BlockHeader) => {\n      if (error) {\n        console.error(error);\n        return;\n      }\n\n      web3.eth.getBlock(blockHeader.number).then(async (block: Block) => {\n        return this.call("BLOCK", block).then(observable => {\n          observable.subscribe(console.log);\n        });\n      });\n    });\n  }\n\n  private call(pattern: string, data: Block): Promise<Observable<any>> {\n    const handler: MessageHandler | undefined = this.messageHandlers.get(pattern);\n\n    if (!handler) {\n      return Promise.resolve(EMPTY);\n    }\n\n    return handler(data);\n  }\n\n  public close(): void {\n    this.subscription.unsubscribe();\n  }\n}\n'),r.createElement("p",null,"Block has a list of transaction`s ids. This mean in the real life you probably want to get full information about those transactions and process it somehow, but in this example controller just returns a list of transactions back. There is no actual need to return information about processed transactions because fully processed Block is not going to be removed from blockchain, but it is useful for logging"),r.createElement(j,{language:"typescript"},'import {Observable} from "rxjs";\nimport {Controller} from "@nestjs/common";\nimport {MessagePattern} from "@nestjs/microservices";\nimport {Block} from "web3/eth/types";\n\nimport {EthereumService} from "./ethereum.service";\n\n@Controller()\nexport class EthereumController {\n  constructor(private readonly ethereumService: EthereumService) {}\n\n  @MessagePattern("BLOCK")\n  public block(block: Block): Observable<object> {\n    return from(block.transactions);\n  }\n}\n'),r.createElement(R,{slug:"ethereum-server-for-nestjs"}))},O=function(){return r.createElement("div",null,r.createElement(E,{date:"2019-11-03T14:18:19.626Z"}),r.createElement(s.Typography,{component:"h2",variant:"h4"},"JWT based authorization for Nest.js"),r.createElement("p",null,"In my previous article I showed hot to implement",r.createElement(s.Link,{component:p,to:"/articles/session-based-authorization-for-nestjs"},"session based authorization"),"Today I`m going to publish solution which uses JWT. The main difference between these approaches is: Sessions are good for client-to-server communication, where you can store session id in cookies and get user specific data based on this id. JSON Web Token is good for server-to-server communication where there are no cookies and state could be retrieved from request itself"),r.createElement("p",null,"This is how controller with authorization looks like"),r.createElement(j,{language:"typescript"},'import {Controller, Get} from "@nestjs/common";\n\nimport {UserEntity} from "./user.entity";\nimport {Roles, User} from "../common/decorators";\nimport {UserRole} from "./interfaces";\nimport {UserService} from "./user.service";\n\n\n@Controller("users")\nexport class UserController {\n  constructor(private readonly userService: UserService) {}\n\n  @Get("profile")\n  getGloballyProtectedProfile(@User() user: UserEntity): UserEntity {\n    return user;\n  }\n\n  @Get("/list")\n  @Roles(UserRole.Admin)\n  public findAll(): Promise<{list: UserEntity[]; count: number}> {\n    return this.userService.findAndCount().then(([list, count]) => ({list, count}));\n  }\n}\n'),r.createElement("p",null,"And the bootstrap function is pretty simple too"),r.createElement(j,{language:"typescript"},'import passport from "passport";\nimport {NestFactory, Reflector} from "@nestjs/core";\n\nimport {ApplicationModule} from "./app.module";\nimport {JwtGuard, RolesGuard} from "./common/guards";\n\n\nasync function bootstrap(): Promise<void> {\n  const app = await NestFactory.create(ApplicationModule);\n\n  app.use(passport.initialize());\n\n  const reflector = app.get(Reflector);\n  app.useGlobalGuards(new JwtGuard(reflector));\n  app.useGlobalGuards(new RolesGuard(reflector));\n\n  await app.listen(3000);\n}\n\nbootstrap();\n'),r.createElement("p",null,"I tried to make this code as much as possible similar to previous one so you can compare it and even use both approaches at the same time. For this I also added facebook support and redis session storage."),r.createElement("p",null,"As always you can find code in my",r.createElement(b,{href:"https://github.com/TrejGun/jwt-based-authorization-for-nestjs"},"github repo")),r.createElement(R,{slug:"jwt-based-authorization-for-nestjs"}))},C=function(){return r.createElement("div",null,r.createElement(E,{date:"2019-11-03T14:56:19.626Z"}),r.createElement(s.Typography,{component:"h2",variant:"h4"},"GraphQL based authorization for Nest.js"),r.createElement("p",null,"This is already third article in a row about authorization in Nest.js. It is still the same codebase but instead of @Controllers it uses @Resolvers, all other stuff is pretty straight forward."),r.createElement(j,{language:"typescript"},'import {Query, Resolver} from "@nestjs/graphql";\n\nimport {User, Roles} from "../common/decorators";\nimport {UserRole} from "./interfaces";\nimport {UserEntity} from "./user.entity";\nimport {UserService} from "./user.service";\nimport {UserListType} from "./types";\n\n\n@Resolver(() => UserEntity)\nexport class UserResolver {\n  constructor(private readonly userService: UserService) {}\n\n  @Query(_returns => UserEntity)\n  public profile(@User() user: UserEntity): UserEntity {\n    return user;\n  }\n\n  @Roles(UserRole.Admin)\n  @Query(_returns => UserListType)\n  public listUsers(): Promise<UserListType> {\n    return this.userService.findAndCount().then(([list, count]) => ({list, count}));\n  }\n\n}\n'),r.createElement("p",null,"User has to call GraphQL mutation using his email and password to obtain JWT accessToken and refreshToken."),r.createElement(j,{language:"graphql"},'mutation {\n  login(\n    email: "trejgun@gmail.com",\n    password: "My5up3r5tr0ngP@55w0rd"\n  ) {\n    accessToken\n    refreshToken\n    accessTokenExpiry\n    refreshTokenExpiry\n  }\n}\n'),r.createElement("p",null,"Then he has to put accessToken in Bearer authentication header which will be processed by passport.js and resolved back into user. This user would be available in all Queries/Mutations using @User decorator. See first code sample."),r.createElement("p",null,"Decorators and Guards are implemented a little bit different for GraphQL but works in the same way so you would not even notice a difference in coding."),r.createElement("p",null,"As always you can find code in my",r.createElement(b,{href:"https://github.com/TrejGun/graphql-based-authorization-for-nestjs"},"github repo")),r.createElement(R,{slug:"graphql-based-authorization-for-nestjs"}))},P=n(278),N=Object(s.makeStyles)((function(){return{map:{width:600,height:400,backgroundColor:"#c0c0c0",position:"relative"},spinner:{top:"50%",left:"50%",position:"absolute",marginTop:-20,marginLeft:-20},input:{width:600,display:"block"}}}),{name:"NovaPoshta"}),L=function(e){var t=e.setWarehouse,n=e.googleMapsApiKey,o=e.novaPoshtaApiKey,a=N();return n&&o?"ReactSnap"===navigator.userAgent?null:r.createElement(P.a,{onError:console.error.bind(console),googleMapsApiKey:n,novaPoshtaApiKey:o,className:a.map,onSelect:t,getCoordinates:function(e,t){e({lat:50.45466,lng:30.5238}),window.navigator.geolocation.getCurrentPosition((function(t){e({lat:t.coords.latitude,lng:t.coords.longitude})}),t)},options:{zoomControlOptions:{position:"RIGHT_CENTER"}}},r.createElement(s.CircularProgress,{className:a.spinner})):null};function M(e,t){return function(e){if(Array.isArray(e))return e}(e)||function(e,t){if(!(Symbol.iterator in Object(e)||"[object Arguments]"===Object.prototype.toString.call(e)))return;var n=[],r=!0,o=!1,a=void 0;try{for(var s,i=e[Symbol.iterator]();!(r=(s=i.next()).done)&&(n.push(s.value),!t||n.length!==t);r=!0);}catch(e){o=!0,a=e}finally{try{r||null==i.return||i.return()}finally{if(o)throw a}}return n}(e,t)||function(){throw new TypeError("Invalid attempt to destructure non-iterable instance")}()}var U,G,q=function(){var e=N(),t=M(r.useState(null),2),n=t[0],o=t[1],a=M(r.useState(""),2),i=a[0],l=a[1],c=M(r.useState(""),2),p=c[0],u=c[1];return r.createElement("div",null,r.createElement(E,{date:"2019-11-10T13:20:19.556Z"}),r.createElement(s.Typography,{component:"h2",variant:"h4"},"Nova Poshta Google Maps widget"),r.createElement("p",null,"I`m working not only with Nest.js and server side JS in my practice, so today let me show you dead simple widget for selecting Nova Poshta warehouse on Google map, which obviously should have been written by Nova Poshta itself, but obviously had not been."),r.createElement("p",null,"You can play with example but have to enter your valid API keys."),r.createElement(s.Input,{className:e.input,placeholder:"Google Maps API key",onChange:function(e){return l(e.target.value)}}),r.createElement(s.Input,{className:e.input,placeholder:"Nova Poshta API key",onChange:function(e){return u(e.target.value)}}),r.createElement("br",null),r.createElement(L,{setWarehouse:o,googleMapsApiKey:i,novaPoshtaApiKey:p}),r.createElement("p",null,"Selected: ",n?n.Description:"N/A"),r.createElement("p",null,"This widget loads all warehouses of Nova Poshta which is about 13.5 Mb of data and renders about 5900 markers on the map. This is quite a lot and can cause significant performance degradation of you site, you were warned!"),r.createElement("p",null,"As always you can find code in my",r.createElement(b,{href:"https://github.com/TrejGun/trejgun-nova-poshta-google-maps"},"github repo")),r.createElement(R,{slug:"nova-poshta-google-maps-widget"}))},H=function(){return r.createElement("div",null,r.createElement(E,{date:"2019-11-14T18:40:19.556Z"}),r.createElement(s.Typography,{component:"h2",variant:"h4"},"Collecting data from workers in Nest.js"),r.createElement("p",null,"In Nest.js request to microcervice worker returns an Observable object, but the request to database usually return promise. How to deal with situation when you have to combine result from several workers and each result can be an array with 0+ elements?"),r.createElement("p",null,"For this promise result should be converted to Observable and elements emitted one by one"),r.createElement(j,{language:"typescript"},'import {FindConditions} from "typeorm";\nimport {Observable, from} from "rxjs";\nimport {mergeMap} from "rxjs/operators";\nimport {Controller} from "@nestjs/common";\nimport {MessagePattern, Payload} from "@nestjs/microservices";\n\nimport {WorkerService} from "./worker.service";\nimport {WorkerEntity} from "./worker.entity";\n\n\n@Controller()\nexport class WorkerController {\n  constructor(private readonly workerService: WorkerService) {}\n\n  @MessagePattern("GET_RESULT")\n  public getResult(@Payload() payload: FindConditions<WorkerEntity>): Observable<WorkerEntity> {\n    return from(this.workerService.getResult(payload)).pipe(mergeMap(e => e));\n  }\n}\n'),r.createElement(j,{language:"typescript"},'import {FindConditions, Repository} from "typeorm";\nimport {Injectable, NotFoundException} from "@nestjs/common";\nimport {InjectRepository} from "@nestjs/typeorm";\n\nimport {WorkerEntity} from "./worker.entity";\n\n\n@Injectable()\nexport class WorkerService {\n  constructor(\n    @InjectRepository(WorkerEntity)\n    private readonly workerEntityRepository: Repository<WorkerEntity>,\n  ) {}\n\n  public getResult(where: FindConditions<WorkerEntity>): Promise<Array<WorkerEntity>> {\n    if (Math.random() < .01) {\n      throw new NotFoundException()\n    }\n    return this.workerEntityRepository.find(where);\n  }\n}\n'),r.createElement("p",null,"On the other side orchestrator will create (two) connections to such workers and receive stream of results from each of them. These streams has to be merged into one.Then combined stream drained and all elements returned to the frontend as an array"),r.createElement(j,{language:"typescript"},'import {Args, Query, Resolver} from "@nestjs/graphql";\n\nimport {ResultType} from "./orchestrator.type";\nimport {OrchestratorService} from "./orchestrator.service";\n\n\n@Resolver()\nexport class OrchestratorResolver {\n  constructor(private readonly orchestratorService: OrchestratorService) {}\n\n  @Query(_returns => [ResultType])\n  async getOrchestrator(\n    @Args({name: "param1", type: () => String}) param1: string,\n    @Args({name: "param2", type: () => String}) param2: string,\n  ): Promise<Array<IResult>> {\n    return this.orchestratorService.getCombinedResult({param1, param2});\n  }\n}\n'),r.createElement(j,{language:"typescript"},'import {EMPTY, merge} from "rxjs";\nimport {catchError, reduce, timeout} from "rxjs/operators";\nimport {Injectable} from "@nestjs/common";\nimport {Client, ClientProxy, Transport} from "@nestjs/microservices";\n\n\n@Injectable()\nexport class OrchestratorService {\n  @Client({\n    transport: Transport.RMQ,\n    options: {\n      urls: [process.env.RMQ_URL],\n      query: "first",\n    },\n  })\n  client1: ClientProxy;\n\n  @Client({\n    transport: Transport.RMQ,\n    options: {\n      urls: [process.env.RMQ_URL],\n      query: "second",\n    },\n  })\n  client2: ClientProxy;\n\n\n  public async getCombinedResult(params: any): Promise<Array<IResult>> {\n    const seed: Array<IResult> = [];\n    return merge(\n      ...[this.client1, this.client2].map(client =>\n        client.send<IResult | Error>("GET_BALANCE", params)\n          .pipe(timeout(1000), catchError(error => {\n            console.error(error);\n            return EMPTY;\n          })),\n      ),\n    )\n      .pipe(reduce((memo, result: IResult) => memo.concat(result), seed))\n      .toPromise();\n  }\n}\n'),r.createElement("p",null,"In comparison to promise based solution, this method is faster and more stable, because it allows you to end stream by timeout even if not all elements were received."),r.createElement(R,{slug:"collecting-data-from-workers-in-nestjs"}))},z=function(){return r.createElement("div",null,r.createElement(E,{date:"2019-11-16T14:31:19.556Z"}),r.createElement(s.Typography,{component:"h2",variant:"h4"},"How to convert HttpException to RpcException?"),r.createElement("p",null,"It is really easy to return erroneous http response in Nest.js application, you just have to throw",r.createElement("em",null,"HttpException")," or one of it`s implementations like ",r.createElement("em",null,"UnauthorizedException"),",",r.createElement("em",null,"NotFoundException")," or ",r.createElement("em",null,"BadRequestException"),". It is meaningful and you don`t have to reinvent the wheel each time. But What about microservices? Potentially you can throw the same ",r.createElement("em",null,"Exception")," from there too, but on the other side you will receive",r.createElement("em",null,"Internal Server Error"),", which is not meaningful at all, so to use built-in exceptions they has to be converted to ",r.createElement("em",null,"RpcException")," first. To do this I wrote this simple filter."),r.createElement(j,{language:"typescript"},'import {Observable, throwError} from "rxjs";\nimport {Catch, RpcExceptionFilter, HttpException} from "@nestjs/common";\nimport {RpcException} from "@nestjs/microservices";\n\n\n@Catch(HttpException)\nexport class HttpToRpcExceptionConverter implements RpcExceptionFilter<HttpException> {\n  catch(exception: HttpException): Observable<any> {\n    return throwError(new RpcException(exception.message.error));\n  }\n}\n'),r.createElement(R,{slug:"how-to-convert-http-exception-to-rpc-exception"}))},W=function(){return r.createElement("div",null,r.createElement(E,{date:"2019-11-23T19:18:19.556Z"}),r.createElement(s.Typography,{component:"h2",variant:"h4"},"Apollo client and authorization with Nest.js"),r.createElement("p",null,"As of recently I was working on the front-end part of authorization, for my project based on GraphQL. So today I want to share Apollo client configuration which you can use with example from my previous article",r.createElement(s.Link,{component:p,to:"/articles/graphql-based-authorization-for-nestjs"},"GraphQL based authorization for Nest.js"),"This code is for ",r.createElement("em",null,"react-native")," but can be easily adopted to any other frontend framework."),r.createElement(j,{language:"typescript"},"export interface IAuth {\n  accessToken: string;\n  accessTokenExpiresAt: number;\n  refreshToken?: string;\n  refreshTokenExpiresAt?: number;\n}\n"),r.createElement(j,{language:"typescript"},'export const AUTH_STORE_KEY = "AUTH_STORE_KEY";\n\nexport enum ERRORS {\n  AUTH_ERROR = "AUTH_ERROR",\n}\n'),r.createElement(j,{language:"typescript"},'import AsyncStorage from "@react-native-community/async-storage";\n\n\nexport async function getItem<T>(key: string): Promise<T | null> {\n  const value = await AsyncStorage.getItem(key);\n  return value ? JSON.parse(value) : null;\n}\n\nexport async function setItem(key: string, value: any): Promise<void> {\n  return AsyncStorage.setItem(key, JSON.stringify(value));\n}\n'),r.createElement(j,{language:"typescript"},'import {ApolloClient} from "apollo-client";\nimport {createHttpLink} from "apollo-link-http";\nimport {InMemoryCache} from "apollo-cache-inmemory";\nimport {onError} from "apollo-link-error";\nimport {setContext} from "apollo-link-context";\n// eslint-disable-next-line import/named\nimport {GATEWAY_URL} from "react-native-dotenv";\nimport {ApolloLink, Observable} from "apollo-link";\n\nimport {AUTH_STORE_KEY, ERRORS} from "./constants";\nimport {getItem, setItem} from "./storage";\nimport {IAuth} from "./interface";\n\n\nconst httpLink = createHttpLink({\n  uri: GATEWAY_URL,\n});\n\nconst authLink = setContext(async (_, {headers}) => {\n  const auth = await getItem<IAuth>(AUTH_STORE_KEY);\n\n  if (auth) {\n    return {\n      headers: {\n        ...headers,\n        authorization: auth ? `Bearer ${auth.accessToken}` : "",\n      },\n    };\n  } else {\n    return {headers};\n  }\n});\n\nconst refreshToken = async (): Promise<IAuth | null> => {\n  let auth = await getItem<IAuth>(AUTH_STORE_KEY);\n\n  if (!auth) {\n    return null;\n  }\n\n  const response = await fetch(GATEWAY_URL, {\n    method: "POST",\n    headers: {\n      "Content-Type": "application/json",\n    },\n    body: JSON.stringify({\n      query: `\n        mutation($refreshToken: String!) {\n          refreshToken(refreshToken: $refreshToken) {\n            accessToken\n            refreshToken\n            accessTokenExpiresAt\n            refreshTokenExpiresAt\n          }\n        }\n      `,\n      variables: auth,\n    }),\n  });\n\n  const json = await response.json();\n\n  auth = json.data ? json.data.refreshToken : null;\n\n  await setItem(AUTH_STORE_KEY, auth);\n\n  return auth;\n};\n\n// @ts-ignore\nconst retryLink = onError(({graphQLErrors, operation, forward}) => {\n  // GraphQL types are so broken :(\n  // @ts-ignore\n  if (graphQLErrors && graphQLErrors[0].message.statusCode === 401) {\n    return new Observable((observer): void => {\n      refreshToken()\n        .then(auth => {\n          if (!auth) {\n            throw new Error(ERRORS.AUTH_ERROR);\n          }\n          operation.setContext(({headers = {}}: Record<string, any>) => ({\n            headers: {\n              ...headers,\n              authorization: `Bearer ${auth.accessToken}`,\n            },\n          }));\n        })\n        .then(() => {\n          forward(operation).subscribe(observer);\n        })\n        .catch(error => {\n          observer.error(error);\n        });\n    });\n  }\n  // do not return empty observable from here\n});\n\nexport const client = new ApolloClient({\n  link: ApolloLink.from([authLink, retryLink, httpLink]),\n  cache: new InMemoryCache(),\n});\n'),r.createElement("p",null,"You should consider to use it if you have application with client side rendering and should not otherwise. In other words do not use it with Next.js and Server Side Rendering (better don`t use Next.js at all), because you won`t be able to obtain and refresh ",r.createElement("em",null,"JWT")," from server side. Use session based auth and share cookies between clients but this would be a topic for my next article"),r.createElement(R,{slug:"apollo-client-for-authorization-with-nestjs"}))},_=function(){return r.createElement("div",null,r.createElement(E,{date:"2019-11-24T19:40:19.556Z"}),r.createElement(s.Typography,{component:"h2",variant:"h4"},"SSR Next.js authentication for GraphQL Nest.js application"),r.createElement("p",null,"In last article I promised to show how to authenticate Next.js frontend with Server Side Rendering with Nest.js GraphQL application. Here it comes. The theory is REST client posts login/password to ",r.createElement("em",null,"/login"),"endpoint and saves session to cookies, then shares this session with Apollo client to make requests to",r.createElement("em",null,"/graphql")," endpoint. To illustrate backend lets take code from another my article",r.createElement(s.Link,{component:p,to:"/articles/session-based-authorization-for-nestjs"},"Session based authorization for Nest.js")),r.createElement(j,{language:"typescript"},'import {Request} from "express";\nimport {promisify} from "util";\nimport {Body, Controller, Get, Post, Req, UseGuards, HttpCode} from "@nestjs/common";\n\nimport {Public, User} from "../common/decorators";\nimport {LoginGuard, LocalGuard} from "../common/guards";\nimport {UserEntity} from "../user/user.entity";\nimport {UserService} from "../user/user.service";\nimport {UserCreateSchema} from "./schemas";\n\n\n@Controller("auth")\n@UseGuards(LocalGuard)\nexport class AuthController {\n  constructor(private readonly userService: UserService) {}\n\n  @Public()\n  @UseGuards(LoginGuard)\n  @HttpCode(200)\n  @Post("login")\n  public login(@User() user: UserEntity): UserEntity {\n    return user;\n  }\n\n  @Public()\n  @Get("logout")\n  public logout(@Req() req: Request): void {\n    req.logout();\n  }\n\n  @Public()\n  @Post("signup")\n  public async signup(@Body() data: UserCreateSchema, @Req() req: Request): Promise<UserEntity> {\n    const user = await this.userService.create(data);\n    // @ts-ignore\n    await promisify(req.logIn.bind(req))(user);\n    return user;\n  }\n}\n'),r.createElement("p",null,"This controller will authorize user based on credentials sent by this small fetch wrapper"),r.createElement(j,{language:"typescript"},'import fetch from "isomorphic-unfetch";\n\n\nexport default function ajax<T>(url: string, body: object): Promise<T> {\n  const headers = new Headers();\n  headers.append("Accept", "application/json");\n  headers.append("Content-Type", "application/json; charset=utf-8");\n  return fetch(`http:/localhost:3000/${url}`, {\n    headers,\n    method: "POST",\n    credentials: "include",\n    mode: "cors",\n    body: JSON.stringify(body),\n  }).then(response => {\n    if (response.status === 200) {\n      return response.json();\n    }\n    throw new Error(response.statusText);\n  });\n}\n\n\n// ajax<IUser>("auth/login", {\n//   login: "trejgun@gmail.com",\n//   password: "My5up3r5tr0ngP@55w0rd"\n// })\n'),r.createElement("p",null,"Now it`s time to look at ApplicationModule and GraphQL configuration."),r.createElement(j,{language:"typescript"},'import {Module} from "@nestjs/common";\nimport {Request} from "express";\nimport {GraphQLModule} from "@nestjs/graphql";\nimport {TypeOrmModule} from "@nestjs/typeorm";\n\nimport {AuthModule} from "./auth/auth.module";\nimport ormconfig from "./orm.config";\n\n\n@Module({\n  imports: [\n    TypeOrmModule.forRoot(ormconfig),\n    GraphQLModule.forRootAsync({\n      useFactory: () => ({\n        debug: process.env.NODE_ENV !== "production",\n        playground: process.env.NODE_ENV !== "production",\n        context: ({req}: {req: Request}): any => ({req}),\n        autoSchemaFile: "./schema.gql",\n        cors: {\n          origin: ["http://localhost:3001"],\n          credentials: true,\n        },\n      }),\n    }),\n    AuthModule,\n  ],\n})\nexport class ApplicationModule {}\n'),r.createElement("p",null,"CORS should be there because frontend and backend apps are most likely running on different ports even on localhost. In this example I assume backend is on 3000 and frontend is on 3001 port. CORS middleware also should be applied to app itself for login to work."),r.createElement("p",null,"And here comes actual Apollo config. It is tiny but powerful."),r.createElement(j,{language:"typescript"},'import {ApolloClient} from "apollo-client";\nimport {InMemoryCache} from "apollo-cache-inmemory";\nimport withApollo from "next-with-apollo";\nimport {createHttpLink} from "apollo-link-http";\nimport fetch from "isomorphic-unfetch";\n\n\nconst link = createHttpLink({\n  fetch,\n  uri: `http:/localhost:3000/graphql`,\n  fetchOptions: {\n    credentials: "include",\n    mode: "cors",\n  },\n});\n\nexport default withApollo(\n  ({initialState = {}}: {initialState?: any}) =>\n    new ApolloClient({\n      link,\n      cache: new InMemoryCache().restore(initialState),\n    }),\n  {getDataFromTree: "ssr"},\n);\n'),r.createElement("p",null,"Notice how it uses ",r.createElement("em",null,"unfetch")," to make REST requests from backend and the part it shares with frontend fetch call, that is used for CORS. And cookies are shared by ",r.createElement("em",null,"withApollo")," or rather it passes headers from initial page request (which includes cookies) to subsequent GraphQL requests."),r.createElement(R,{slug:"ssr-nextjs-authentication-for-graphql-nestjs-application"}))},F=function(){return r.createElement("div",null,r.createElement(E,{date:"2019-11-26T18:56:19.556Z"}),r.createElement(s.Typography,{component:"h2",variant:"h4"},"Bindings for using Final Form with Material UI Autocomplete"),r.createElement("p",null,"Recently Material UI team added new component to Lab - Autocomplete 🎉. Before that users had to use react-select or other alternatives, which required too much code and efforts, but now, when it is native and has no documentation, examples and code samples over internet; I want to capitalize on that and publish my solution for Final Form integration."),r.createElement(j,{language:"typescript"},'import * as React from "react";\nimport {useIntl} from "react-intl";\n\nimport {FieldRenderProps} from "react-final-form";\n\nimport TextField, {TextFieldProps} from "@material-ui/core/TextField";\nimport Autocomplete, {AutocompleteProps} from "@material-ui/lab/Autocomplete";\n\n\ndeclare interface IAutoCompleteWrapperProps {\n  max: number;\n}\n\ntype AutoCompleteWrapperProps = TextFieldProps &\n  AutocompleteProps &\n  FieldRenderProps<string, HTMLElement> &\n  IAutoCompleteWrapperProps;\n\ndeclare interface IOption {\n  value: string;\n  label: string;\n}\n\nexport const AutoCompleteWrapper: React.FC<AutoCompleteWrapperProps> = props => {\n  const {formatMessage} = useIntl();\n\n  const {input, meta, helperText, max, options = [], ...rest} = props;\n  const {name, onChange, value, multiple, ...restInput} = input;\n  const label = formatMessage({id: `form.labels.${name}`});\n  const placeholder = formatMessage({id: `form.placeholders.${name}`});\n\n  const error = meta.error || meta.submitError;\n  const hasError = error && (meta.dirty || meta.submitFailed);\n\n  const [maxReached, setMaxReached] = React.useState(false);\n\n  return (\n    <Autocomplete\n      {...rest}\n      multiple={multiple}\n      options={\n        multiple ? (maxReached ? [] : options.filter((option: IOption) => !value.includes(option.value))) : options\n      }\n      defaultValue={\n        multiple\n          ? options.filter((option: any) => value.includes(option.value))\n          : options.find((option: any) => option.value === value)\n      }\n      onChange={\n        multiple\n          ? (_e: React.ChangeEvent<{}>, values: Array<IOption>): void => {\n            setMaxReached(value.length >= max - 1);\n            onChange(values.map(({value}: IOption) => value));\n          }\n          : (_e: React.ChangeEvent<{}>, {value}: IOption): void => onChange(value)\n      }\n      getOptionLabel={(option: IOption): string => option.label}\n      noOptionsText={\n        maxReached\n          ? formatMessage({id: "components.autocomplete.max"}, {max})\n          : formatMessage({id: "components.autocomplete.no"})\n      }\n      renderInput={(params: any): React.ReactElement => (\n        <TextField\n          {...params}\n          {...restInput}\n          label={label}\n          placeholder={placeholder}\n          helperText={hasError ? formatMessage({id: error}, {label}) : helperText}\n          error={hasError}\n          fullWidth\n        />\n      )}\n    />\n  );\n};\n\nAutoCompleteWrapper.defaultProps = {\n  max: Infinity,\n};\n'),r.createElement("p",null,"Hope this helps"),r.createElement(R,{slug:"bindings-for-using-final-form-with-material-ui-autocomplete"}))},B=function(){return r.createElement(a.d,null,r.createElement(a.b,{component:S,path:"/articles/custom-transport-for-nestjs",exact:!0}),r.createElement(a.b,{component:A,path:"/articles/session-based-authorization-for-nestjs",exact:!0}),r.createElement(a.b,{component:I,path:"/articles/ethereum-server-for-nestjs",exact:!0}),r.createElement(a.b,{component:O,path:"/articles/jwt-based-authorization-for-nestjs",exact:!0}),r.createElement(a.b,{component:C,path:"/articles/graphql-based-authorization-for-nestjs",exact:!0}),r.createElement(a.b,{component:q,path:"/articles/nova-poshta-google-maps-widget",exact:!0}),r.createElement(a.b,{component:H,path:"/articles/collecting-data-from-workers-in-nestjs",exact:!0}),r.createElement(a.b,{component:z,path:"/articles/how-to-convert-http-exception-to-rpc-exception",exact:!0}),r.createElement(a.b,{component:W,path:"/articles/apollo-client-for-authorization-with-nestjs",exact:!0}),r.createElement(a.b,{component:_,path:"/articles/ssr-nextjs-authentication-for-graphql-nestjs-application",exact:!0}),r.createElement(a.b,{component:F,path:"/articles/bindings-for-using-final-form-with-material-ui-autocomplete",exact:!0}),r.createElement(a.a,{to:"/page-not-found"}))},Q=function(){return r.createElement("div",null,r.createElement(E,{date:"2019-11-03T15:25:20.324Z"}),r.createElement(s.Typography,{component:"h2",variant:"h4"},"About this site"),r.createElement("p",null,"I used to code js for pretty long time, and was quite tired of doing same stuff over and over again. At some point I even thought server side js have faced some stagnation. An then someone, some where mentioned",r.createElement(b,{href:"https://nestjs.com/"},"Nest.js"),", one month later I tried it and felt in love. Unfortunately it looks like the documentation is not as great as framework itself, so I decided to add my 2 cents to popularization on this awesome framework. Once I already had blog about coding and other related stuff, so I decided to make second attempt, and post here some tutorials and gotchas."))},K=function(){return r.createElement("div",null,r.createElement(s.Typography,{component:"h2",variant:"h4"},"Page Not Found"))},Y=function(){return r.createElement("div",null,r.createElement(s.Typography,{component:"h2",variant:"h4"},"Terms and conditions"),r.createElement("p",null,"This is a static website with",r.createElement(b,{href:"https://github.com/TrejGun/trejgun.github.io"},"open source code"),". It is not using cookies and/or not collecting any personal data by itself. All articles and source code of this site are available for education purposes under MIT license"),r.createElement("p",null,"Site also uses facebook`s comments, so facebook will track you, collect your data and use it for advertising purposes. This page exists only to fulfill facebook`s requirements."))},J=Object(o.hot)((function(){return r.createElement(d,null,r.createElement(a.d,null,r.createElement(a.b,{path:"/",component:f,exact:!0}),r.createElement(a.b,{path:"/articles",component:B}),r.createElement(a.b,{path:"/about",component:Q}),r.createElement(a.b,{path:"/terms-and-conditions",component:Y}),r.createElement(a.b,{path:"/page-not-found",component:K}),r.createElement(a.a,{to:"/page-not-found"})))})),D=n(20);U=J,(G=document.getElementById("app"))&&D[G.hasChildNodes()?"hydrate":"render"](r.createElement(s.MuiThemeProvider,{theme:Object(s.createMuiTheme)({typography:{fontSize:16}})},r.createElement(s.CssBaseline,null),r.createElement(i.a,null,r.createElement(U,null))),G)},45:function(e,t,n){e.exports=n(273)}});
//# sourceMappingURL=main.js.map